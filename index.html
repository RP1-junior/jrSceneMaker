<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #202020;
    font-family: sans-serif;
    color: white;
  }

  #ui {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 10;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    background: rgba(0, 0, 0, 0.6);
    padding: 6px;
    border-radius: 4px;
    user-select: none;
  }

  #ui button,
  #ui input[type="file"],
  #ui label {
    font-size: 13px;
    color: white;
  }

  #ui button {
    background: #333;
    border: 1px solid #555;
    border-radius: 3px;
    padding: 4px 8px;
    cursor: pointer;
  }

  #ui button:hover {
    background: #555;
  }

  #sidebar {
    position: absolute;
    top: 80px;
    left: 10px;
    z-index: 10;
    width: 220px;
    max-height: 70%;
    overflow: auto;
    background: rgba(0, 0, 0, 0.6);
    padding: 6px;
    border-radius: 4px;
    user-select: none;
  }

  #modelList {
    list-style: none;
    padding: 0;
    margin: 6px 0 0 0;
  }

  #modelList li {
    cursor: pointer;
    padding: 4px 6px;
    border-radius: 3px;
  }

  #modelList li:hover {
    background: #444;
  }

  #properties {
    font-size: 12px;
    white-space: pre-wrap;
    margin-top: 6px;
  }

  #helpOverlay {
    position: absolute;
    bottom: 10px;
    right: 10px;
    z-index: 20;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    font-size: 12px;
    line-height: 1.4;
    padding: 8px 10px;
    border-radius: 4px;
    max-width: 220px;
    display: none;
    /* hidden by default */
  }

  #helpOverlay strong {
    display: block;
    margin-bottom: 4px;
    font-size: 13px;
  }
  .drop-above {
border-top: 2px solid #4cafef;
}
.drop-into {
background: rgba(76, 175, 239, 0.2);
}

</style>

<div id="ui">
<input type="file" id="file"><br>
<button id="translate">Translate (W)</button>
<button id="rotate">Rotate (E)</button>
<button id="scale">Scale (R)</button>
<button id="delete">Delete (Del)</button>
<button id="undo">Undo (Ctrl+Z)</button>
<button id="resetCamera">Reset Camera</button>
<button id="exportJson">Export JSON</button>
<br>
<label><input type="checkbox" id="snap"> Snap</label>
<input type="number" id="canvasSize" value="20" min="20" max="100"> Canvas Size<br>
</div>

<div id="sidebar">
  <strong>Models</strong>
  <ul id="modelList"></ul>
  <hr>
  <strong>Properties</strong>
  <pre id="properties"></pre>
</div>

<div id="helpOverlay">
  <strong>Hotkeys</strong>
  W – Move<br>
  E – Rotate<br>
  R – Scale<br>
  Q – Detach gizmo<br>
  Shift+Q – Re‑attach gizmo<br>
  F – Frame selected<br>
  Ctrl+Z – Undo<br>
  Click model – Focus it<br>
  Double‑click empty – Reset to canvas<br>
  H – Toggle this help
</div>

<ul id="contextMenu" style="
position: absolute;
display: none;
background: #222;
border: 1px solid #555;
padding: 4px;
list-style: none;
z-index: 1000;
">
<!-- Items will be injected dynamically -->
</ul>

<script type="text/javascript">
   // ===== Constants & Styles =====
const SNAP_STEP = 1;
const LABEL_SIZE = 0.2;
const LABEL_OFFSET = 0.5;
const BOX_COLORS = { hover:0x99ccff, selected:0x0000ff, editing:0xffffff };

// Inject minimal styles for visual feedback
(function(){
  const style = document.createElement('style');
  style.textContent = `
    #modelList li.drop-above { border-top:2px solid #4cafef; }
    #modelList li.drop-into { background:rgba(76,175,239,0.2); }
    #modelList li.selected { background:#444; }
  `;
  document.head.appendChild(style);
})();

// ===== Scene setup =====
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x202020);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(3,3,6);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

const orbit = new THREE.OrbitControls(camera, renderer.domElement);
orbit.enableDamping = true;

let groundSize = 20;
orbit.minDistance = 1;
orbit.maxDistance = groundSize * 1.5;

const transform = new THREE.TransformControls(camera, renderer.domElement);
scene.add(transform);

let selectedObject = null;
let selectedObjects = [];
let hoveredObject = null;
let draggedItem = null;

scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.2));
const dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.position.set(5,10,7);
scene.add(dirLight);

let grid = new THREE.GridHelper(groundSize, groundSize, 0x888888, 0x444444);
grid.userData.isSelectable = false;
grid.raycast = () => {};
scene.add(grid);

let ruler = null;

// ===== UI refs =====
const loader = new THREE.GLTFLoader();
const fileInput = document.getElementById("file");
const modelList = document.getElementById("modelList");
const propertiesPanel = document.getElementById("properties");
const snapCheckbox = document.getElementById("snap");
const canvasSizeInput = document.getElementById("canvasSize");
const btnTranslate = document.getElementById("translate");
const btnRotate = document.getElementById("rotate");
const btnScale = document.getElementById("scale");
const btnDelete = document.getElementById("delete");
const btnUndo = document.getElementById("undo");
const btnResetCamera = document.getElementById("resetCamera");

let modelCounter = 1;

let loadedFont = null;
const fontLoader = new THREE.FontLoader();
fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', font => {
  loadedFont = font;
  ruler = createRuler(groundSize, 1);
  addRulerLabels(ruler, groundSize, 1, loadedFont);
  ruler.userData.isSelectable = false;
  scene.add(ruler);
});

// ===== Utilities =====
function getBox(obj){ return new THREE.Box3().setFromObject(obj); }

function updateAllVisuals(obj){
  if(!obj) return;
  // Do not clamp here to preserve user-intended placement unless user transforms
  updateModelProperties(obj);
  updatePropertiesPanel(obj);
  updateBoxHelper(obj);
  addBoundingBoxDimensions(obj);
}

function cleanupObject(obj){
  if (!obj) return;
  // Box helper
  if (obj.userData.boxHelper) {
    scene.remove(obj.userData.boxHelper);
    obj.userData.boxHelper.geometry?.dispose();
    obj.userData.boxHelper.material?.dispose();
    delete obj.userData.boxHelper;
  }
  // Dimensions
  if (obj.userData.dimGroup) {
    scene.remove(obj.userData.dimGroup);
    obj.userData.dimGroup.traverse(c=>{
      c.geometry?.dispose();
      c.material?.dispose();
    });
    delete obj.userData.dimGroup;
  }
  // Sidebar entry (+child list if group)
  if (obj.userData.listItem) {
    const li = obj.userData.listItem;
    const next = li.nextSibling;
    li.remove();
    if (next && next.tagName === "UL") next.remove();
    delete obj.userData.listItem;
  }
}

function snapUniformScale(obj, step=SNAP_STEP){
  const box = getBox(obj);
  const size = box.getSize(new THREE.Vector3());
  const maxDim = Math.max(size.x, size.y, size.z);
  const snapped = Math.max(step, Math.round(maxDim/step)*step);
  if (maxDim > 0) obj.scale.multiplyScalar(snapped/maxDim);
}

function clampToCanvas(obj){
  const half = groundSize/2;
  const box = getBox(obj);
  const size = box.getSize(new THREE.Vector3());
  const center = box.getCenter(new THREE.Vector3());
  const minX = center.x - size.x/2, maxX = center.x + size.x/2;
  const minZ = center.z - size.z/2, maxZ = center.z + size.z/2;
  if (minX < -half) obj.position.x += -half - minX;
  if (maxX >  half) obj.position.x -= maxX - half;
  if (minZ < -half) obj.position.z += -half - minZ;
  if (maxZ >  half) obj.position.z -= maxZ - half;
  if (box.min.y < 0) obj.position.y += -box.min.y;
}

function updateModelProperties(model){
  if(!model) return;
  const box = getBox(model);
  const size = box.getSize(new THREE.Vector3());
  model.userData.properties = {
    pos: model.position.clone(),
    scl: model.scale.clone(),
    size: size.clone()
  };
}

function updatePropertiesPanel(model){
  if(!model || !model.userData.properties){
    propertiesPanel.textContent = "";
    return;
  }
  const p = model.userData.properties;
  propertiesPanel.textContent =
    `Position: (${p.pos.x.toFixed(2)}, ${p.pos.y.toFixed(2)}, ${p.pos.z.toFixed(2)})\n`+
    `Scale: (${p.scl.x.toFixed(2)}, ${p.scl.y.toFixed(2)}, ${p.scl.z.toFixed(2)})\n`+
    `Bounds: (${p.size.x.toFixed(2)}, ${p.size.y.toFixed(2)}, ${p.size.z.toFixed(2)})`;
}

function createBoxHelperFor(model){
  const helper = new THREE.BoxHelper(model, BOX_COLORS.selected);
  helper.material.transparent = true;
  helper.material.opacity = 0.9;
  helper.visible = false;
  model.userData.boxHelper = helper;
  scene.add(helper);
}

function updateBoxHelper(model, color=null){
  if (!model?.userData.boxHelper) return;
  model.userData.boxHelper.update();
  if (color) model.userData.boxHelper.material.color.setHex(color);
}

function setHelperVisible(model, visible){
  if(model?.userData.boxHelper) model.userData.boxHelper.visible = !!visible;
}

function addBoundingBoxDimensions(model){
  if(!loadedFont) return;
  if(model.userData.dimGroup){
    scene.remove(model.userData.dimGroup);
    model.userData.dimGroup.traverse(c=>{
      c.geometry?.dispose();
      c.material?.dispose();
    });
  }
  const box = getBox(model);
  const size = box.getSize(new THREE.Vector3());
  const center = box.getCenter(new THREE.Vector3());
  const group = new THREE.Group();
  const mat = new THREE.MeshBasicMaterial({color:0xffff00});
  const label = (text,pos)=>{
    const mesh = new THREE.Mesh(
      new THREE.TextGeometry(text,{font:loadedFont,size:LABEL_SIZE,height:0}),
      mat
    );
    mesh.position.copy(pos);
    group.add(mesh);
  };
  label(`${size.x.toFixed(2)}m`, new THREE.Vector3(center.x, box.max.y+0.2, box.min.z-LABEL_OFFSET));
  label(`${size.y.toFixed(2)}m`, new THREE.Vector3(box.max.x+LABEL_OFFSET, center.y, box.min.z-LABEL_OFFSET));
  label(`${size.z.toFixed(2)}m`, new THREE.Vector3(center.x, box.min.y-LABEL_OFFSET, box.max.z+LABEL_OFFSET));
  scene.add(group);
  model.userData.dimGroup = group;
}

// Only used for grouping pivots — keep original pivot for loaded models
function recenterPivotToBottomCenter(obj){
  const box = new THREE.Box3().setFromObject(obj);
  if(box.isEmpty()) return;
  const center = box.getCenter(new THREE.Vector3());
  const bottomCenter = new THREE.Vector3(center.x, box.min.y, center.z);
  obj.children.forEach(child => child.position.sub(bottomCenter));
  obj.position.add(bottomCenter);
}

// ===== Transforms: initial & helpers =====
function storeInitialTransform(obj){
  obj.userData.initialTransform = {
    pos: obj.position.clone(),
    rot: obj.quaternion.clone(),
    scale: obj.scale.clone()
  };
}

function resetTransform(obj){
  if(!obj.userData.initialTransform) return;
  const t = obj.userData.initialTransform;
  obj.position.copy(t.pos);
  obj.quaternion.copy(t.rot);
  obj.scale.copy(t.scale);
  updateAllVisuals(obj);
}

function dropToFloor(obj){
  const box = new THREE.Box3().setFromObject(obj);
  if (box.isEmpty()) return;
  obj.position.y -= box.min.y;
  updateAllVisuals(obj);
}

// ===== Selection (unified) =====
function selectObject(obj, additive=false, toggle=false){
  // Clear selection
  if (!additive && !toggle) {
    selectedObjects.forEach(o=>{
      o.userData.listItem?.classList.remove("selected");
      setHelperVisible(o,false);
      if (o.userData.dimGroup) scene.remove(o.userData.dimGroup);
    });
    selectedObjects = [];
  }

  // Toggle remove
  if (toggle && selectedObjects.includes(obj)) {
    selectedObjects = selectedObjects.filter(o=>o!==obj);
    obj.userData.listItem?.classList.remove("selected");
    setHelperVisible(obj,false);
    updatePropertiesPanel(selectedObjects[selectedObjects.length-1] || null);
    return;
  }

  // Add to selection
  if (!selectedObjects.includes(obj)) selectedObjects.push(obj);
  selectedObject = obj;

  transform.attach(obj);
  obj.userData.listItem?.classList.add("selected");
  setHelperVisible(obj,true);
  updateBoxHelper(obj, BOX_COLORS.selected);
  addBoundingBoxDimensions(obj);
  updateModelProperties(obj);
  updatePropertiesPanel(obj);
}

function selectFromSidebar(obj, li, e){
  const additive = !!(e && (e.shiftKey||e.ctrlKey||e.metaKey));
  const toggle = !!(e && (e.ctrlKey||e.metaKey));
  selectObject(obj, additive, toggle);
}

function selectFromCanvas(obj, additive){
  selectObject(obj, !!additive, false);
}

// ===== Sidebar (DRY creation) =====
function createSidebarItem(obj, name, isGroup=false){
  const li = document.createElement("li");
  const label = document.createElement("span");
  label.textContent = name;
  li.appendChild(label);

  li.onclick = e => selectFromSidebar(obj, li, e);
  li.ondblclick = e => {
    if (e.target === label) makeLabelEditable(label, obj);
    else { selectFromSidebar(obj, li, e); frameCameraOn(obj); }
  };

  obj.userData.listItem = li;
  modelList.appendChild(li);
  makeDraggable(li, obj);

  if (isGroup) {
    const childList = document.createElement("ul");
    childList.style.listStyle = "none";
    childList.style.paddingLeft = "12px";
    childList.style.margin = "4px 0 6px 0";
    childList.style.display = "none";
    li.after(childList);
  }
}

function addModelToList(model, name){
  createSidebarItem(model, name, false);
}

function addGroupToList(group, name){
  createSidebarItem(group, name, true);
  const childList = group.userData.listItem.nextSibling;
  group.children.forEach(child=>{
    const childLi = document.createElement("li");
    const childLabel = document.createElement("span");
    childLabel.textContent = child.name || "Model";
    childLi.appendChild(childLabel);

    childLi.onclick = e => selectFromSidebar(child, childLi, e);
    childLi.ondblclick = e => {
      if (e.target === childLabel) makeLabelEditable(childLabel, child);
      else { selectFromSidebar(child, childLi, e); frameCameraOn(child); }
    };

    child.userData.listItem = childLi;
    childList.appendChild(childLi);
    makeDraggable(childLi, child);
  });
}

// ===== Inline renaming =====
function makeLabelEditable(label, obj){
  const input = document.createElement("input");
  input.type = "text";
  input.value = label.textContent;
  input.style.width = "80%";

  label.replaceWith(input);
  input.focus();

  const finish = () => {
    obj.name = (input.value.trim() || obj.name || "Unnamed");
    const newLabel = document.createElement("span");
    newLabel.textContent = obj.name;
    newLabel.ondblclick = () => makeLabelEditable(newLabel, obj);
    input.replaceWith(newLabel);
    obj.userData.listItem.firstChild = newLabel;
  };
  input.addEventListener("blur", finish);
  input.addEventListener("keydown", e=>{
    if (e.key === "Enter") finish();
    if (e.key === "Escape") { input.value = obj.name; finish(); }
  });
}

function renameSelectedObject(){
  if (selectedObjects.length !== 1) return;
  const li = selectedObjects[0].userData.listItem;
  const label = li?.querySelector("span");
  if (label) makeLabelEditable(label, selectedObjects[0]);
}

// ===== Drag-and-drop (reorder + nest) =====
function makeDraggable(li, obj){
  li.draggable = true;

  li.addEventListener("dragstart", e=>{
    draggedItem = { li, obj };
    e.dataTransfer.effectAllowed = "move";
  });

  li.addEventListener("dragover", e=>{
    e.preventDefault();
    e.dataTransfer.dropEffect = "move";
    li.classList.remove("drop-above", "drop-into");
    const rect = li.getBoundingClientRect();
    const offsetY = e.clientY - rect.top;
    if (obj instanceof THREE.Group && offsetY > rect.height/2) li.classList.add("drop-into");
    else li.classList.add("drop-above");
  });

  li.addEventListener("dragleave", ()=> li.classList.remove("drop-above","drop-into"));

  li.addEventListener("drop", e=>{
    e.preventDefault();
    li.classList.remove("drop-above","drop-into");
    if (!draggedItem || draggedItem.li === li) return;

    const targetObj = obj;
    const rect = li.getBoundingClientRect();
    const offsetY = e.clientY - rect.top;

    if (targetObj instanceof THREE.Group && offsetY > rect.height/2) {
      // Nest into group
      targetObj.add(draggedItem.obj);
      let childList = li.nextSibling;
      if (!(childList && childList.tagName === "UL")) {
        childList = document.createElement("ul");
        childList.style.listStyle = "none";
        childList.style.paddingLeft = "12px";
        childList.style.margin = "4px 0 6px 0";
        childList.style.display = "block";
        li.after(childList);
      }
      childList.appendChild(draggedItem.li);
    } else {
      // Reorder at same level
      li.parentNode.insertBefore(draggedItem.li, li);
      const parent = targetObj.parent;
      parent.remove(draggedItem.obj);
      const index = parent.children.indexOf(targetObj);
      parent.children.splice(index, 0, draggedItem.obj);
      draggedItem.obj.parent = parent;
    }
    draggedItem = null;
  });
}

modelList.addEventListener("dragover", e => e.preventDefault());
modelList.addEventListener("drop", e=>{
  e.preventDefault();
  if (!draggedItem) return;
  if (draggedItem.obj.parent && draggedItem.obj.parent !== scene) {
    draggedItem.obj.parent.remove(draggedItem.obj);
    scene.add(draggedItem.obj);
  }
  modelList.appendChild(draggedItem.li);
  draggedItem = null;
});

// ===== Ruler =====
function createRuler(size, step=1){
  const group = new THREE.Group();
  const mat = new THREE.LineBasicMaterial({color:0xaaaaaa});
  for(let i=-size/2;i<=size/2;i+=step){
    group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(i,0,-size/2),new THREE.Vector3(i,0.1,-size/2)]), mat));
    group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(i,0,size/2),new THREE.Vector3(i,0.1,size/2)]), mat));
    group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-size/2,0,i),new THREE.Vector3(-size/2,0.1,i)]), mat));
    group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(size/2,0,i),new THREE.Vector3(size/2,0.1,i)]), mat));
  }
  return group;
}

function addRulerLabels(group, size, step, font){
  const mat = new THREE.MeshBasicMaterial({color:0xaaaaaa});
  for(let i=-size/2;i<=size/2;i+=step){
    if(i===0) continue;
    const labelX = new THREE.Mesh(new THREE.TextGeometry(`${i}m`,{font,size:LABEL_SIZE,height:0}), mat);
    labelX.position.set(i,0.1,-size/2-LABEL_OFFSET);
    group.add(labelX);

    const labelZ = new THREE.Mesh(new THREE.TextGeometry(`${i}m`,{font,size:LABEL_SIZE,height:0}), mat);
    labelZ.position.set(-size/2-LABEL_OFFSET,0.1,i);
    group.add(labelZ);
  }
}

// ===== File loading (preserve original pivot & transform) =====
fileInput.addEventListener("change", e=>{
  const file = e.target.files[0]; if(!file) return;
  const url = URL.createObjectURL(file);
  loader.load(url, gltf=>{
    const model = gltf.scene;
    model.userData.isSelectable = true;
    model.name = (file.name || ("Model "+modelCounter++)).replace(/\.[^/.]+$/, "");
    createBoxHelperFor(model);

    // Preserve original local origin and transform from file: no centering, no floor drop, no pivot recenter
    scene.add(model);

    addModelToList(model, model.name);
    storeInitialTransform(model);
    selectObject(model);
    updateBoxHelper(model);
    frameCameraOn(model);
    saveState();
  });
});

// ===== Group / Ungroup =====
function groupSelectedObjects(){
  if (selectedObjects.length < 2) return;
  const group = new THREE.Group();
  group.userData.isSelectable = true;
  group.name = "Group " + Date.now();

  selectedObjects.forEach(obj=>{
    // remove UI helpers for children (they will be recalculated for group)
    if(obj.userData.boxHelper){ scene.remove(obj.userData.boxHelper); delete obj.userData.boxHelper; }
    if(obj.userData.dimGroup){ scene.remove(obj.userData.dimGroup); delete obj.userData.dimGroup; }

    // Re-parent while preserving world transform
    group.attach(obj);

    // remove old sidebar entries
    if (obj.userData.listItem) {
      const li = obj.userData.listItem;
      const next = li.nextSibling;
      li.remove();
      if(next && next.tagName==="UL") next.remove();
      delete obj.userData.listItem;
    }
  });

  scene.add(group);

  // Set intuitive pivot for the group only
  recenterPivotToBottomCenter(group);

  createBoxHelperFor(group);
  addGroupToList(group, group.name);
  storeInitialTransform(group);

  selectObject(group);
  updateAllVisuals(group);
}

function ungroupSelectedObject(){
  if (selectedObjects.length !== 1) return;
  const group = selectedObjects[0];
  if (!(group instanceof THREE.Group)) return;

  // Move children to root while preserving world transforms
  while (group.children.length > 0) {
    const child = group.children[0];

    // Re-parent while preserving world transform
    scene.attach(child);

    // Recreate helpers removed during grouping so selection shows box after ungroup
    createBoxHelperFor(child);

    // Recreate sidebar entries
    if (child instanceof THREE.Group) addGroupToList(child, child.name || "Group");
    else addModelToList(child, child.name || "Model");

    updateAllVisuals(child);
  }

  cleanupObject(group);
  scene.remove(group);
  selectedObjects = [];
  selectedObject = null;
  transform.detach();
  updatePropertiesPanel(null);
}

// ===== Delete =====
function deleteObject(obj){
  if(!obj) return;
  if(transform.object===obj) transform.detach();

  // If group: remove children first cleanly from UI and scene
  if (obj instanceof THREE.Group) {
    const children = [...obj.children];
    children.forEach(child=>{
      cleanupObject(child);
      obj.remove(child);
    });
  }

  cleanupObject(obj);
  if(obj.parent) obj.parent.remove(obj);

  selectedObjects = selectedObjects.filter(o=>o!==obj);
  if(selectedObject===obj) selectedObject=null;
  updatePropertiesPanel(selectedObject||null);
}

// ===== Camera helpers =====
function animateCamera(toPos, toTarget, duration=800){
  const fromPos = camera.position.clone();
  const fromTarget = orbit.target.clone();
  const start = performance.now();
  const ease = t => (t<0.5?2*t*t:-1+(4-2*t)*t);
  function step(now){
    const t = Math.min(1, (now-start)/duration);
    const k = ease(t);
    camera.position.lerpVectors(fromPos, toPos, k);
    orbit.target.lerpVectors(fromTarget, toTarget, k);
    camera.lookAt(orbit.target);
    if (t<1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

function frameCameraOn(obj){
  const box = getBox(obj);
  const sizeLen = box.getSize(new THREE.Vector3()).length();
  const center = box.getCenter(new THREE.Vector3());
  const newPos = center.clone().add(new THREE.Vector3(sizeLen,sizeLen,sizeLen));
  animateCamera(newPos, center);
}

function resetCamera(){
  if(selectedObject) frameCameraOn(selectedObject);
  else animateCamera(new THREE.Vector3(groundSize,groundSize,groundSize), new THREE.Vector3(0,0,0));
}

// ===== Canvas size & snap =====
canvasSizeInput.addEventListener("change", e=>{
  groundSize = parseFloat(e.target.value) || 20;
  scene.remove(grid);
  grid = new THREE.GridHelper(groundSize, groundSize, 0x888888, 0x444444);
  grid.userData.isSelectable = false;
  scene.add(grid);

  if (ruler) scene.remove(ruler);
  if (loadedFont) {
    ruler = createRuler(groundSize,1);
    addRulerLabels(ruler,groundSize,1,loadedFont);
    ruler.userData.isSelectable = false;
    scene.add(ruler);
  }
  orbit.maxDistance = groundSize * 1.5;

  selectedObjects.forEach(o=>updateAllVisuals(o));
});

snapCheckbox.addEventListener("change", e=>{
  const enabled = e.target.checked;
  transform.setTranslationSnap(enabled?1:null);
  transform.setRotationSnap(enabled?THREE.MathUtils.degToRad(15):null);
});

// ===== Hover & selection (canvas) =====
renderer.domElement.addEventListener("mousemove", e=>{
  const rect = renderer.domElement.getBoundingClientRect();
  const mouse = new THREE.Vector2(
    ((e.clientX-rect.left)/rect.width)*2-1,
    -((e.clientY-rect.top)/rect.height)*2+1
  );
  const raycaster = new THREE.Raycaster();
  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(scene.children, true);
  let obj = null;
  if (hits.length>0){
    obj = hits[0].object;
    while (obj.parent && !obj.userData.isSelectable) obj = obj.parent;
    if (!obj.userData.isSelectable) obj = null;
  }
  if (hoveredObject && !selectedObjects.includes(hoveredObject)) setHelperVisible(hoveredObject,false);
  hoveredObject = obj;
  if (hoveredObject && !selectedObjects.includes(hoveredObject)){
    updateBoxHelper(hoveredObject, BOX_COLORS.hover);
    setHelperVisible(hoveredObject,true);
  }
});

renderer.domElement.addEventListener("click", e=>{
  const rect = renderer.domElement.getBoundingClientRect();
  const mouse = new THREE.Vector2(
    ((e.clientX-rect.left)/rect.width)*2-1,
    -((e.clientY-rect.top)/rect.height)*2+1
  );
  const raycaster = new THREE.Raycaster();
  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(scene.children, true);
  if (hits.length>0){
    let obj = hits[0].object;
    while (obj.parent && !obj.userData.isSelectable) obj = obj.parent;
    if (obj.userData.isSelectable){
      selectFromCanvas(obj, e.shiftKey);
      frameCameraOn(obj);
    }
  }
});

// ===== Double-click focus =====
renderer.domElement.addEventListener("dblclick", e=>{
  if (transform.dragging) return;
  const rect = renderer.domElement.getBoundingClientRect();
  const mouse = new THREE.Vector2(
    ((e.clientX-rect.left)/rect.width)*2-1,
    -((e.clientY-rect.top)/rect.height)*2+1
  );
  const raycaster = new THREE.Raycaster();
  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(scene.children, true);
  let target = null;
  if (hits.length>0){
    let obj = hits[0].object;
    while (obj.parent && !obj.userData.isSelectable) obj = obj.parent;
    if (obj.userData.isSelectable) target = obj;
  }
  if (target) { selectFromCanvas(target, false); frameCameraOn(target); }
  else resetCamera();
});

// ===== Keyboard shortcuts =====
window.addEventListener("keydown", e=>{
  const key = e.key.toLowerCase();
  const inForm = (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA");
  const isHotkey = ["w","e","r","q","f","h","z","delete"].includes(key);
  if (inForm && !isHotkey) return;

  switch(key){
    case "w": transform.setMode("translate"); break;
    case "e": transform.setMode("rotate"); break;
    case "r": transform.setMode("scale"); break;
    case "q":
      if(e.shiftKey){ if(selectedObject) transform.attach(selectedObject); }
      else transform.detach();
      break;
    case "f": if(selectedObject) frameCameraOn(selectedObject); break;
    case "h": {
      const helpOverlay = document.getElementById("helpOverlay");
      if(helpOverlay) helpOverlay.style.display = (helpOverlay.style.display==="none"||helpOverlay.style.display==="")?"block":"none";
      break;
    }
    case "delete":
      if(selectedObjects.length) [...selectedObjects].forEach(deleteObject);
      else if (selectedObject) deleteObject(selectedObject);
      break;
    default:
      if ((e.ctrlKey||e.metaKey) && key==="z"){ e.preventDefault(); undo(); }
      break;
  }
});

// ===== Fix #ui buttons =====
btnTranslate.onclick = () => transform.setMode("translate");
btnRotate.onclick = () => transform.setMode("rotate");
btnScale.onclick = () => transform.setMode("scale");
btnDelete.onclick = () => {
  if(selectedObjects.length) [...selectedObjects].forEach(deleteObject);
  else if (selectedObject) deleteObject(selectedObject);
};
btnUndo.onclick = () => undo();
btnResetCamera.onclick = () => resetCamera();

// ===== Resize =====
window.addEventListener("resize", ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  selectedObjects.forEach(o=>updateBoxHelper(o));
  if (hoveredObject) updateBoxHelper(hoveredObject);
});

// ===== Transform events =====
transform.addEventListener("dragging-changed", e=>{
  orbit.enabled = !e.value;
  selectedObjects.forEach(o=>{
    updateBoxHelper(o, e.value?BOX_COLORS.editing:BOX_COLORS.selected);
    setHelperVisible(o,true);
  });
  if (!e.value) saveState();
});

transform.addEventListener("objectChange", ()=>{
  if(!selectedObject) return;
  if(transform.getMode()==="scale"){
    const s = selectedObject.scale.x;
    selectedObject.scale.set(s,s,s);
    snapUniformScale(selectedObject, SNAP_STEP);
  }
  // Clamp on user transform to keep objects interactable within canvas
  clampToCanvas(selectedObject);
  updateAllVisuals(selectedObject);
});

// ===== Undo =====
const undoStack = [];
function saveState(){
  if (selectedObject) {
    undoStack.push({
      uuid: selectedObject.uuid,
      pos: selectedObject.position.clone(),
      rot: selectedObject.quaternion.clone(), // store quaternion to avoid ambiguity
      scale: selectedObject.scale.clone()
    });
  }
}
function undo(){
  if (!selectedObject || !undoStack.length) return;
  for (let i=undoStack.length-1; i>=0; i--){
    if (undoStack[i].uuid === selectedObject.uuid){
      const last = undoStack.splice(i,1)[0];
      selectedObject.position.copy(last.pos);
      selectedObject.quaternion.copy(last.rot);
      selectedObject.scale.copy(last.scale);
      updateAllVisuals(selectedObject);
      break;
    }
  }
}

// ===== Render loop =====
function animate(){
  requestAnimationFrame(animate);
  orbit.update();
  renderer.render(scene, camera);
}
animate();

// ===== Context menu =====
const contextMenu = (function(){
  const menu = document.createElement('ul');
  menu.id = 'contextMenu';
  menu.style.position = 'absolute';
  menu.style.display = 'none';
  menu.style.background = '#222';
  menu.style.border = '1px solid #555';
  menu.style.padding = '4px';
  menu.style.listStyle = 'none';
  menu.style.zIndex = '1000';
  document.body.appendChild(menu);
  return menu;
})();

const contextActions = {
  "Group": () => groupSelectedObjects(),
  "Ungroup": () => ungroupSelectedObject(),
  "Rename": () => renameSelectedObject(),
  "Reset Transform": () => selectedObjects.forEach(resetTransform),
  "Drop to Floor": () => selectedObjects.forEach(dropToFloor),
  "Select All": () => selectAllSidebar(),
  "Deselect All": () => deselectAllSidebar()
};

function showContextMenu(x,y,actions){
  contextMenu.innerHTML = "";
  actions.forEach(action=>{
    const li = document.createElement("li");
    li.textContent = action;
    li.style.padding = "4px 12px";
    li.style.cursor = "pointer";
    li.onmouseenter = () => li.style.background = "#444";
    li.onmouseleave = () => li.style.background = "transparent";
    li.onclick = () => { contextMenu.style.display="none"; contextActions[action]?.(); };
    contextMenu.appendChild(li);
  });
  contextMenu.style.left = x+"px";
  contextMenu.style.top = y+"px";
  contextMenu.style.display = "block";
}
document.addEventListener("click", ()=> contextMenu.style.display="none");

// Canvas context menu
renderer.domElement.addEventListener("contextmenu", e=>{
  e.preventDefault();
  let actions = ["Select All","Deselect All"];
  if (selectedObjects.length > 1) actions = ["Group","Reset Transform","Drop to Floor","Select All","Deselect All"];
  else if (selectedObjects.length === 1) {
    const obj = selectedObjects[0];
    actions = ["Rename","Reset Transform","Drop to Floor","Select All","Deselect All"];
    if (obj instanceof THREE.Group) actions.unshift("Ungroup");
  }
  showContextMenu(e.clientX, e.clientY, actions);
});

// Sidebar context menu
modelList.addEventListener("contextmenu", e=>{
  e.preventDefault();
  const li = e.target.closest("li");
  if (!li) return;
  const obj = findObjectByListItem(li);
  if (!obj) return;
  if (!selectedObjects.includes(obj)) selectFromSidebar(obj, li, e);

  let actions = ["Select All","Deselect All"];
  if (selectedObjects.length > 1) actions = ["Group","Reset Transform","Drop to Floor","Select All","Deselect All"];
  else if (selectedObjects.length === 1) {
    actions = ["Rename","Reset Transform","Drop to Floor","Select All","Deselect All"];
    if (obj instanceof THREE.Group) actions.unshift("Ungroup");
  }
  showContextMenu(e.clientX, e.clientY, actions);
});

function findObjectByListItem(li){
  let found = null;
  scene.traverse(obj=>{
    if (obj.userData?.listItem === li) found = obj;
  });
  return found;
}

function selectAllSidebar(){
  deselectAllSidebar();
  const topItems = [...modelList.querySelectorAll(":scope > li")];
  topItems.forEach(li=>{
    const obj = findObjectByListItem(li);
    if (obj?.userData.isSelectable){
      li.classList.add("selected");
      selectedObjects.push(obj);
      setHelperVisible(obj,true);
      updateBoxHelper(obj, BOX_COLORS.selected);
      addBoundingBoxDimensions(obj);
    }
  });
  selectedObject = selectedObjects[selectedObjects.length-1] || null;
  if (selectedObject){
    transform.attach(selectedObject);
    updateModelProperties(selectedObject);
    updatePropertiesPanel(selectedObject);
  }
}

function deselectAllSidebar(){
  selectedObjects.forEach(o=>{
    o.userData.listItem?.classList.remove("selected");
    setHelperVisible(o,false);
    if (o.userData.dimGroup) scene.remove(o.userData.dimGroup);
  });
  selectedObjects = [];
  selectedObject = null;
  transform.detach();
  updatePropertiesPanel(null);
}

// ===== Export JSON (quaternions) =====
document.getElementById("exportJson").onclick = ()=>{
  function buildNode(obj){
    if (!obj.userData?.isSelectable) return null;

    const box = new THREE.Box3().setFromObject(obj);
    const size = box.getSize(new THREE.Vector3());
    const q = obj.quaternion;

    const rawName = (obj.name && obj.name.length) ? obj.name :
      (obj.userData.listItem ? obj.userData.listItem.textContent : "FILE");
    const baseName = rawName.replace(/\.[^/.]+$/, "");

    const node = {
      Resource_sName: baseName,
      Resource_sReference: baseName + ".glb",
      Transform_Position_dX: obj.position.x,
      Transform_Position_dY: obj.position.y,
      Transform_Position_dZ: obj.position.z,
      Transform_Rotation_dX: q.x,
      Transform_Rotation_dY: q.y,
      Transform_Rotation_dZ: q.z,
      Transform_Rotation_dW: q.w,
      Transform_Scale_dX: obj.scale.x,
      Transform_Scale_dY: obj.scale.y,
      Transform_Scale_dZ: obj.scale.z,
      Bound_dX: size.x,
      Bound_dY: size.y,
      Bound_dZ: size.z
    };

    if (obj instanceof THREE.Group) {
      node.Resource_bIsGroup = true;
      node.Children = [];
      obj.children.forEach(child=>{
        const childNode = buildNode(child);
        if (childNode) node.Children.push(childNode);
      });
    } else {
      node.Resource_bIsGroup = false;
    }
    return node;
  }

  const exportData = [];
  scene.children.forEach(obj=>{
    const node = buildNode(obj);
    if (node) exportData.push(node);
  });

  const jsonText = JSON.stringify(exportData, null, 2);
  const blob = new Blob([jsonText], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = "index.msf.json"; a.click();
  URL.revokeObjectURL(url);
};

</script>


<!-- Core Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<!-- Controls & Loaders -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
